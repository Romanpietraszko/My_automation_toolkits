//args argumenty	
//Najważniejsze składniki snipetu-> body ciało czyli co robi, desription opis, prefix nazwa
//${1:nazwa}Placeholder z domyślną wartością – możesz ją zmienić, ale daje Ci punkt startowy
//$1, $2, $3 Tab stop – miejsce, do którego przeskakuje kursor po wstawieniu snippetu
//$0	Ostateczna pozycja kursora – gdzie trafisz na końcu edycji snippetu
{
	 "Pętla/For": {                                                   
		"prefix": "pętlafor",
	 	"body": [
	 		"for ${1:i}  in range(${2:5}):",
	 		"    ${0:# TODO: coś zrób}"
	 	],
	 	"description": "składnia pętli for wstawia z opisem"
	 },
	 
	"funkcja":{
		"prefix": "funkcja",
		"body": [
			"def ${1:nazwa_funkcji}(${2:arg1},${3:arg2})",
			"   ${0:# Todo: return}"
		],
		"description": "Wzór funkcji"	
	 },
	 "Klasa":{
		"prefix": "Class",
		"body": ["class${1:NazwaKlasy}:",
		"def __init__(self,${2:argument1},${3:argument2}):",
			"self.${2:argument1} = ${2:argument1}",
			 "self.${3:argument2} = ${3:argument2}",
		 "def ${4:metoda}(self):",
		 	"${0:#ciało metody}",
			 "return coś"

	 ],
	 "description": "Składnia klasy"       
	 },
	 "Pętla/while":{
		"prefix": "while",
		"body":[ "while True",
				 "    ${0:# Todo: zrob coś}"
	],
	"description":"Składnia pętli while nie skończonej"
	 },
	 "Pętla/while/Z/warunkiem":{
		"prefix": "while not",
		"body":[ "while not ${1:jakiś_warunek():}",
				 "   ${0:# Todo np: jakiś_warunek = cokolwiek()}"
	],
	"description":"Składnia pętli while not z warunkiem"
	 },
	  "Pętla/while/Z/Licznikiem":{
		"prefix": "while licznik",
		"body":[ "${1:i} = ${2:0}",
    		"while ${1:i} < ${3:5}:",
    		"    ${4:print(${1:i})}",
    		"    ${1:i} += 1",
    		"${0}"
	],
	"description":"Składnia pętli while z licznikiem"
	 },
	 "Pętla/while/z/Przerwaniem":{
		"prefix": "while break",
		"body":[   "while True:",
   				   "    ${1:warunek} = ${2:input(\"Podaj coś: \")}",
   				   "    if ${1:warunek} == ${3:\"exit\"}:",
   					 "        break",
   				   "    ${0:# TODO: zrób coś z warunkiem}"
  ],
	 "description": "Pętla while z przerwaniem"
	 },
	 "ifpodstawowy": {
	 "prefix": "if",
  	 "body": [
		"if ${1:warunek}:",
		"   ${0:#Todo kod do wykonania}"
  ],
  "description": "Podstawowy if"
},
	"ifzelse": {
	  "prefix": "ifelse",
	  "body": [
		"if ${1:warunek}:",
		"   ${2:#Todo kod jeśli warunek prawdziwy}",
		"else:",
		"   ${0:#Todo kod jeśli warunek jest fałszywy}"
	  ],
	  "description": "Opis"
	},
	"if/else/elif": {
	  "prefix": "ifelseelif",
	  "body": [
		"if ${1:warunek}:",
		"${2:#kod jeśli warunek}",
		"elif${3:#warunek 2}:",
		"${4:#kod jeśli warunek2}",
		"else:",
		"#kod jeśli żaden nie spełniony"
	  ],
	  "description": "if z elif i z else"
	},
	"if/zagnieżdrzony": {
	  "prefix": "ifzif",
	  "body": [
		"if ${1:warunek}:",
		"   if ${2:warunek}:",
		"    ${0:#Kod jeśli oba warunki}"
	  ],
	  "description": "Zagnieżdrzony if"
	},
	"jedno/linikowy/warunek": {
	  "prefix": "krótkiif",
	  "body": [
		"${1:warunek} if warunek else ${0:przeciwny warunek}",
		
	  ],
	  "description": "jedno linijkowy if z else"
	},
	"Łączeniewarunków": {
	  "prefix": "ŁączenieWarunków",
	  "body": [
		"if ${1:warunek logiczny} and ${2:warunek logiczny inny}",
		"if ${2:warunek logiczny 2} or ${3:warunek inny kolejny}",
		"if not ${0: np is_ready}"
	  ],
	  "description": "łączenie warunków "
	},
	"Porównanialogiczne": {
  	"prefix": "porwónajlogicznie",
  	"body": [
	"if a == b",
	"if a != b",
	"if a > b",
	"if a < b ",
	"if a >= b",
	"if a <= b ",
  	],
  	"description": "Porównania logiczne xd"
	//obsługa błędów i walidacji xdd
	},
	"try/except/Klasyczna/Obsługa/Błędów": {
  	"prefix": "try/except",
  	"body": [
	 "try:",
	"   ${1:#kod}",
	"except Expection as e:",
	"    ${0:#kod obsługa błędu}"
  ],
  "description": "Klasyczna obsługa błędów"
},
  "try/except/finally/ObsługaBłędów/Z/Blokiem/który/zawsze/sie/Wykona": {
	  "prefix": "try/except/finally",
	  "body": [
		"try:",
		"   ${1:#kod}",
		"except:",
		"   ${2:# kod obsługa błędu}",
		"finally:",
		"   ${0:#Kod który zawsze się wykona}",
	  ],
	  "description": "Obsługa błędów z blokiem finaly który zawsze się wykona"
	},
	"raise/Reczne/Rzucenie/Wyjątku": {
	  "prefix": "raise",
	  "body": [
		"raise Exception(${0:#treść komunikat błędu})",
		
	  ],
	  "description": "Reczne rzucenie wyjątku"
	},
	"assert/szybka/Walidacja/Warunku": {
	  "prefix": "assert",
	  "body": [
		"assert, ${1:#warunek()}",
	  ],
	  "description": "Szybka walidacja warunku"
	},
	"except/z/wieloma/typami/błędu": {
	  "prefix": "exceptzwielomatypamibłędu",
	  "body": [
		"try:",
		"   ${1:#Todo kod}",
		"except(TypeError,ValueError)as e:",
		"   ${0:#obsugał}"
	  ],
	  "description": "Składnia except obsługującego wiele typów błędów"
	  //Operacje na plikach
	},
	"Otwieranie/pliku/do/odczytu": {
	  "prefix": "withopen",
	  "body": [
		"with open (${1:#'nazwa_pliku.txt','r'}) as f:",
		"    ${0:#Todo dane = f.read()}"
	  ],
	  "description": "Otwieranie pliku do odczytu"
	},
	"Otwieranie/pliku/do/zapisu": {
	  "prefix": "withopenw",
	  "body": [
		"with open (${1:#'nazwa_pliku.txt','w'}) as f:",
		"   ${0:#Todo f.write('tekst')}"
	  ],
	  "description": "Otwieranie pliku do zapisu(nadpisuje)"
	},
	"Otwieranie/pliku/do/dopisania": {
	  "prefix": "withopena",
	  "body": [
		"with open (${1:#'nazwa_pliku.txt','a'}) as f:",
		"${0:#Todo  f.write('dopisany tekst')}"
	  ],
	  "description": "Otwieranie pliku do dopisania"
	},
	"Otczyt/linia/po/lina": {
	  "prefix": "withopenfor",
	  "body": [
		"with open (${1:#'nazwa_pliku.txt','r'}) as f:",
		"   ${1:#for linia in f:}",
		"       ${0:#print (linia)}"
	  ],
	  "description": "Wzrór odczytu linia po lini"
	},
	"Sprawdzenie/czy/plik/istnieje": {
	  "prefix": "sprawdzczyplikistnieje",
	  "body": [
		"import os",
		"if os.path.exists(${1:#'nazwa_pliku.txt'}):",
		"    ${0:#Coś zrób}"
	  ],
	  "description": "Składnia sprawdzenia czy plik istnieje"
	},
	"Usunięcie/pliku": {
	  "prefix": "usunięciepliku",
	  "body": [
		"import os",
		"os.remove(${1:#'nazwa_pliku.txt'})"
	  ],
	  "description": "Usunięcie pliku "
	},
	"lista": {
	  "prefix": "list",
	  "body": [
		"#lista uporządkowana: list = [1,2,3]",
		"# dodanie elementu na koniec: list.append(4)",
		"#usunięcie elementu: list.remove(2)",
		"#usunięcie ostatniego elementu: list.pop() ",
		"#sortowanie listy rosnąco: list.sort()",
		"# odwrócenie kolejności elementów: list.reverse()",
	  ],
	  "description": "Opis"
	},
	"słownik": {
	  "prefix": "dict",
	  "body": [
		"#Słownik nie uporządkowany kolekcja par: dict = {'klucz':'wartość'}",
		"#dodanie nowej pary: dict['nowy'] = 'dodany' ",
		"#Pobieranie wartości z klucza: dict = słownik.get('klucz')",
		"#Usunięcie pary z kluczem: del dict['klucz']",
	  ],
	  "description": "Opis"
	},
	"Zbiór": {
	  "prefix": "zbiór",
	  "body": [
		"#zbiór to nieuporządkowana kolekcja unikalnych elmentów: zbiór = {1,2,3}",
		"#dodanie elementu: zbiór.add(4)",
		"#Usunięcie elementu: zbiór.remove(2)",
		"#Dodanie wielu elementów naraz: zbiór.update({5,6})",
	  ],
	  "description": "Zbiór i operacje na zbiorach"
	},
	"Krotka/tuple": {
	  "prefix": "krotkatuple",
	  "body": [
		"#krotka = (1,2,3)",
		"#wartość = krotka[0]"
	  ],
	  "description": "Krotka inaczej zwana tuple"
	},
	"List/comprehension": {
	  "prefix": "listcomprehension",
	  "body": [
		"Skrótowa forma tworzenia listy na podstawie innej listy często z warunkiem",
		"nowa_lista = [${1:#np. x for x in lista if x >0}]",
	  ],
	  "description": "List comprehension"
	},
	"Iteracja/po/słowniku": {
	  "prefix": "iteracjaposłowniku",
	  "body": [
		"for klucz,wartość in słownik.items()",
		"   ${0:#print(klucz,wartość)}"
	  ],
	  "description": "Iteracja po słowniku"
	},
	//Importy 
	//Import całego modułu
 "ImportModułu": {
   "prefix": "Import",
   "body": [
	 "import nazwa_modułu",
	 
   ],
   "description": "Import całego modułu"
 },
 //Import z aliasem
"Import/Z/aliasem": {
  "prefix": "importzaliasem",
  "body": [
	"import nazwa_modułu as alias",
  ],
  "description": "Import z aliasem"
},
//Import konkretnej funkcji/klasy
"import/konkretnej/funkcji/klasy": {
  "prefix": "importkonkretnejfunkcjiklasy",
  "body": [
	"from nazwa_modułu import funkcja",
  ],
  "description": "wielu importów konkretnej funkcji/klasy"
},
//Import z aliasem konkretnego elementu
"Import/z/aliasem/konkretnego/elementu": {
  "prefix": "importzaliasemkonkretnegoelementu",
  "body": [
	"from nazwa_modułu import funkcja as alias",
  ],
  "description": " wzór importów z aliasem konktetnego elementu"
},
//Import wielu elementów
"Import/wielu/elementów": {
  "prefix": "importwieluelementów",
  "body": [
	"from nazwa_modułu import funkcja1,funkcja2, Klasa",
  ],
  "description": "Wzrór importu wielu elementów"
},
//Import wszystkiego 
"Import/wszystkiego": {
  "prefix": "importwszystkiego",
  "body": [
	"form nazwa_modułu import *"
  ],
  "description": "Niezalecany import wszystkiego"
},
//dekoratory
//@decorator do nakładania dodatkowej logiki na funkcję np.logowanie
"@decorator": {
  "prefix": "@decorator",
  "body": [
	"@decorator",
	"def funkcja():",
	"   #ciało funkcji"
  ],
  "description": "dekorator do nakładania dodatkowej logiki"
},
//Dekorator z parametrem np @retry
"@decorator(argument)": {
  "prefix": "@decorator(argument)",
  "body": [
	"@decorator(${1:argument})",
	"def funkcja():",
	"   ${0:#ciało funkcji}"
  ],
  "description": "dekorator z parametrem"
},
//Metoda niezależna od instacji klasy-nie używa self
"@staticmethod": {
  "prefix": "@staticmethod",
  "body": [
	"class Klasa:",
	"   @staticmethod",
	"   def funkcja():",
	"       # ciało funkcji"
  ],
  "description": "Metoda niezależna od instacji klasy-nie używa self"
},
//Metoda działająca na klasie, nie na obiekcie — używa cls zamiast self.
"@classmethod": {
  "prefix": "@classmethod",
  "body": [
	"class Klasa:",
	"   @classmethod",
	"   def funkcja():",
	"       # ciało funkcji"
  ],
  "description": "Metoda działająca na klasie, nie na obiekcie — używa cls zamiast self."
},
//Tworzysz własny „filtr” na funkcję — np. dodajesz logikę, walidację, cache.
"Własny/dekorator": {
  "prefix": "własnydekorator",
  "body": [
	"def dekorator(${1:funkcja}):",
	   "def wrapper(*args,**kwargs):",
	"    ${2:#coś przed}",
	"    wynik = funkcja(${3:#*args,**kwargs})",
	"    ${4:#coś po}",
	"     return wynik",
	"return wrapper"
  ],
  "description": "Tworzysz własny „filtr” na funkcję — np. dodajesz logikę, walidację, cache."
},
//Obsługa API i HTTP
"PobieranieDanychzAPI": {
  "prefix": "pobieraniedanychzapi",
  "body": [
	"import requests",
	"response = requests.get('https://example.com)",
	"data = response.json()"
  ],
  "description": "Pobieranie danych z API"
},
"Wysyłaniedanychdoapi": {
  "prefix": "wysyłkadanychdoAPI",
  "body": [
	"import requests",

	"playload = {'key':'value'}",
	"response = requests.post('https://example.com/api', json=payload)"
  ],
  "description": "Wysłanie zapytania Post z danymi w formacie Json do API"
},
"AsnychronicznePobranieDanych": {
  "prefix": "AsynchronicznePobranieDanych",
  "body": [
	"import httpx",
	"import asyncio",
	"async def fetch():",
	"   async with httpx.AsyncClient() as clinet:",
	"       response = await clinet.get('https://example.com')",
	"       data = response.json()",
  ],
  "description": "Umożliwia pobieranie danych w sposób asynchroniczny-przydatne w fast api"
	//AI-ML
"NumPy operacje na macierzach": {
  "prefix": "Podstawowy_typ_danych_w_ML_do_matmy",
  "body": [
	"import numpy as np",
	"macierz = np.array([[1,2],[3,4]])"
  ],
  "description": "Tworzy dwumywiarową macierz(array),podstawowy typ danych w ML do obliczeń matmatycznych"
},
"Pandas manipulacja danymi": {
  "prefix": "Wczytywanie_danych_z_pliku_CSV_i_modifikowanie_kolumny",
  "body": [
	"import pandas as pd",
	"df = pd.read_csv('plik.csv')",
	"df['kolumna'] = df['kolumna'].apply(lambda x: x *2)"
  ],
  "description": "Wczytuje dane z pliku CSV i modyfikuje kolumnę — Pandas to must-have do pracy z danymi tabelarycznymi."
},
"Scikit-learn klasyczne ML": {
  "prefix": "Tworzenie_modelu_regresji_logistycznej_trenowanie_i_przewidywanie_wyników_klasyczny_ML_workflow",
  "body": [
	"form sklearn.linear_model import LogisticRegresion",
	"model = LogisticRegresion()",
	"model.fit(X_train, y_train)",
	"pred = model.predict(X_test)"
  ],
  "description": "Tworzy model regresji logistycznej, trenuje go na danych i przewiduje wyniki — klasyczny ML workflow."
},
"TensorFlow deep learning": {
  "prefix": "definiuj_i_trenuj_sieć_neuronową_w_TensorFlow",
  "body": [
	"import tensorflow as tf",
	"model = tf.keras.Sequential([])",
	"model.compile(optimizer = 'adam',loss = 'mse')",
	"model.fit(X,y epochs = 10)"
  ],
  "description": "Definiuje i trenuje sieć neuronową w TensorFlow — używane w projektach deep learningowych."
},
//CLI
"Tworzenie interfejsu CLI z opcjami nazwa i debug": {
  "prefix": "Interfejs_CLI_z_opcjami_debug_nazwa_automatycznehelp",
  "body": [
	//argparse – parser argumentów z linii poleceń
	"import argparse",
	"",
    "parser = arparse.ArgumentyParser(description = 'Opis Programu')",
    "parser.add_argument('--nazwa',type = str, help = 'podaj nazwę])",
	"parser.add_argument('--debug',action = 'store_true', help = 'tryb debugowania')",
	"args = parser.parse_args()",
    "print(args.nazwa)",
  ],
  "description": "worzy interfejs CLI z opcjami --nazwa i --debug. Automatycznie generuje help."
},
},







































































































































































































































































	
}






