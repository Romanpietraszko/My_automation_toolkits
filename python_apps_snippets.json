{
	"Średniej wielkości apka": {
	  "prefix": "średniaapka",
	  "body": [
		"#===Importy===",
		"import logging",
		"#Konfiguracja logowania",
		"logging.basicConfig(level=logging.INFO)",
		"#Klasa 1",
		"class User: ",
		"     def __init__(self,${1:name}:",
		"         self.${1:name} = ${1:name}",
		"     def greet(self): ",
		"         pass #tu dodaj powitanie użytkownika",
		"#Klasa 2",
		"class Product: ",
		"    def __init__(self,${2:title},${3:price}):",
		"       self.${2:title} = ${2:titile}",
		"       self.${3:price} = ${3:price}}",
		"    def apply_discount(self,${4:user},${5:products}):",
		"       self.${4:user} = ${4:user}",
		"       self.${5:products} = ${5:products}",
		"    def calculate_total(self):",
		"        pass #Tu oblicz sumę zamówienia",
		"#Funkcja pomocnicza ",
		" def run_app():",
		"    pass # Tu uruchom aplikację",
		" # Punkt wejścia",
		" if __name__ == '__main__':",
		"    run_app()"
	  ],
	  "description": "Szablon aplikacji średniej z 3 klasami paroma funkcjami"
	},
	" Szablon AI ": {
	  "prefix": "modelAIwzór",
	  "body": [
		"#===Importy===",
		"import numpy as np",
		"from sklearn.model_selection import train_test_split",
		"from sklearn.linear_model import LogisticRegresion # Można podmienić na inny model",
		"# Przygotowywanie danych",
		"def load_data():",
		" Tu załaduj dane lub wygeneruj przykładowe",
		"    x = np.random.rand(100,5) # 100 próbek, 5 cech",
		"    y = np.random.randint(0,2,size = 100)  # Klasy binarne",
		"#===Budowa Modelu===",
		"class AIModel:",
		"   def __init__(self):",
		"     self.model = LogisticRegresion()",
		"   def train(self, X_train, y_train)",
		"       self.model.fit(X_train, y_train)",
		"def predict(self, X_test):",
		"    return self.model.predict(X_test)",
		"def evaluate(self,X_test,y_test):",
		" score = self.model.score(X_test, y_test)",
		" print(f'Acuracy: {score: .2f}')",
		"#===Główna Logika ===",
		"def main():",
		"     X, y = load_data()",
		"     X_train , X_test, y_train, y_test = train_test_split(X,y test_size = 0.2)",
		"     model = AIModel()",
		"     model.train(X_train, y_train)",
		"     predictions = model.predict(X_test)",
		"     model.evaluate(X_test, y_test)",
		"",
		"# ====Punkt WEJŚCIA ===",
		"if __name__ =='main'",
		"   main()",
	  ],
	  "description": "Model AI z użyciem sticky learn"
	},
	"Prototyp v1": {
	  "prefix": "prototypv1",
	  "body": [
		"=== CLI ===",
		"import argparse",
		"import streamlit as st",
		"import yaml",
	    "",
       "parser = argparse.ArgumentParser(description = 'Generator prototypów')",
       "parser.add_argument('--nazwa',required=True)",
	   "parser.add_argument('--komponenty',nargs='+')",
	   "args = parser.parse_args()",
	   "=== Generowanie klasy ===",
	   "def generuj_klasę(nazwa,atrybuty):",
        "   linie = [f'class {nazwa}:']",
		"   linie.append('    def __init__(self,'+','.join(atrybuty)+'):')",
        "   for a in atrybuty:",
		"      linie.append(f'     self.{a} ={a}')",     
        "   return '\n'.join(linie)",
		"# === UI(Streamlit) ===",
		"st.title('Generator Prototypów')",
        "nazwa = st.text_input('Nazwa aplikacji')",
		"komponenty = st.multiselect('Wybierz komponenty',['UI','Backend','AI'])",
        "if st.button('generuj'):",
		"    st.code(generuj_klase(nazwa, komponenty), language = 'python')",
		"# === Prasowaniem YAML ===",
		"def wczytaj_konfiguracje(plik):",
		"  with open(plik) as f:",
		"      return yaml.safe_load(f)",
		"# === AI Podpowiedzi ===",
		"def podpowiedz_snippet(prompt):",
		"# Tu wrzucam zapytanie do AI",
		"# tu mam dostać kod jako string",
		"pass # Placeholder",
		"# === Punkt wejścia ===",
		"if __name__ == '__main__':",
        "   print(generuj_klase(args.nazwa, args.komponenty))",
	  ],
	  "description": "Optymalnie do robienia prototypów z podpięciem AI i streamlit i yaml
},
}
